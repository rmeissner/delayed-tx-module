{
  "language": "Solidity",
  "sources": {
    "contracts/DelayedTxModule.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract Enum {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n}\n\ninterface Executor {\n    /// @dev Allows a Module to execute a transaction.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(address to, uint256 value, bytes calldata data, Enum.Operation operation)\n        external\n        returns (bool success);\n}\n\ncontract DelayedTxModule {\n\n    event NewAnnouncement(address indexed executor, address indexed announcer, bytes32 txHash);\n    \n    string public constant NAME = \"Delayed Transaction Module\";\n    string public constant VERSION = \"1.0.0\";\n\n    bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n\n    bytes32 public constant DELAYED_TRANSACTION_TYPEHASH = keccak256(\n         \"DelayedTransaction(address executor,address to,uint256 value,bytes data,uint8 operation,uint256 nonce)\"\n    );\n\n    struct Config {\n        uint64 delay; // Delay in seconds before an announced transaction can be executed\n        bool requireAnnouncer; // Flag to set if announcer should be checked again before execution\n    }\n    \n    struct Announcement {\n        address announcer; \n        uint64 execTime; // Block time in seconds when the announced transaction can be executed\n        bool requireAnnouncer; // Flag if to check if announcer is still present on execution\n        bool executed; // Flag if the announced transaction was executed\n    }\n    \n    // Executor -> Announcer -> Config\n    mapping (address => mapping (address => Config)) public configs;\n    \n    // Transaction Hash -> Announcement\n    mapping (bytes32 => Announcement) public announcements;\n    \n    function updateConfig(address announcer, uint64 delay, bool requireAnnouncer)\n        public\n    {\n        // Note: msg.sender is the executor\n        configs[msg.sender][announcer] = Config(delay, requireAnnouncer);\n    }\n    \n    function announceTransaction(address executor, address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 nonce) \n        public \n    {\n        // Note: msg.sender is the announcer\n        Config memory config = configs[executor][msg.sender];\n        require(config.delay > 0, \"Could not find valid config for executor and announcer\");\n        // No need to check overflow because Solidity does this now (starting with 0.8.0)\n        uint64 execTime = uint64(block.timestamp) + config.delay;\n        bytes memory approveAnnouncement = abi.encodeWithSignature(\n            \"approveTransactionAnnouncement(address,uint256,bytes,uint8,uint256,address,uint64,bool)\", \n            to, \n            value,\n            data,\n            operation,\n            nonce,\n            msg.sender,\n            execTime,\n            config.requireAnnouncer\n        );\n        // We redirect the announcement via the executor\n        // This is a preemptive check that this modules is enabled and this also notifies the executor that a transaction was announced\n        require(Executor(executor).execTransactionFromModule(address(this), 0, approveAnnouncement, Enum.Operation.Call), \"Could not announce transaction\");\n    }\n    \n    function approveTransactionAnnouncement(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 nonce,\n        address announcer,\n        uint64 execTime,\n        bool requireAnnouncer\n    ) \n        public \n    {\n        // Note: msg.sender is the executor\n        bytes32 txHash = getTransactionHash(msg.sender, to, value, data, operation, nonce);\n        Announcement memory announcement = announcements[txHash];\n        require(!announcement.executed && announcement.execTime == 0, \"Cannot announce same transaction again\");\n        announcements[txHash] = Announcement(announcer, execTime, requireAnnouncer, false);\n        emit NewAnnouncement(msg.sender, announcer, txHash);\n    }\n    \n    function revokeTransactionAnnouncement(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 nonce) \n        public \n    {\n        // Note: msg.sender is the executor\n        bytes32 txHash = getTransactionHash(msg.sender, to, value, data, operation, nonce);\n        delete announcements[txHash];\n    }\n    \n    /// @notice Allows to trigger execution of a delayed transaction that has been announced before.\n    /// @dev This method can be triggered by anyone, as transaction announcement is authorized.\n    /// @param executor Contract that will execute the delayed transaction.\n    /// @param to Destination address of delayed transaction.\n    /// @param value Ether value of delayed transaction.\n    /// @param data Data payload of delayed transaction.\n    /// @param operation Operation type of delayed transaction.\n    /// @param nonce None of delayed transaction.\n    function executeTransaction(address executor, address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 nonce) \n        public \n    {\n        bytes32 txHash = getTransactionHash(executor, to, value, data, operation, nonce);\n        Announcement memory announcement = announcements[txHash];\n        require(announcement.execTime <= block.timestamp, \"Cannot execute transaction yet\");\n        // If the announcer is set we should check if the announcer is still enabled\n        require(\n            !announcement.requireAnnouncer || configs[executor][announcement.announcer].delay > 0, \n            \"Could not find valid config for executor and announcer\"\n        );\n        announcement.executed = true;\n        announcements[txHash] = announcement;\n        // We do not require a success here, so that the hash will always be marked as executed\n        Executor(executor).execTransactionFromModule(to, value, data, operation);\n    }\n    \n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n    \n    /// @dev Generates the data for the delayed transaction hash (required for signing)\n    function generateTransactionHashData(\n        address executor,\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 nonce\n    ) \n        private \n        view \n        returns (bytes memory) \n    {\n        uint256 chainId = getChainId();\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, chainId, this));\n        bytes32 transactionHash = keccak256(\n            abi.encode(DELAYED_TRANSACTION_TYPEHASH, executor, to, value, keccak256(data), operation, nonce)\n        );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator, transactionHash);\n    }\n    \n    function getTransactionHash(address executor, address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 nonce) \n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(generateTransactionHashData(executor, to, value, data, operation, nonce));\n    }\n}"
    },
    "contracts/test/TestExecutor.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract TestExecutor {\n    address public module;\n\n    function setModule(address _module) external {\n        module = _module;\n    }\n\n    function call(address payable to, uint256 value, bytes calldata data) external {\n        bool success;\n        (success,) = to.call{value: value}(data);\n        require(success, \"Call failed\");\n    }\n\n    function execTransactionFromModule(address payable to, uint256 value, bytes calldata data, uint8 operation)\n        external\n        returns (bool success)\n    {\n        require(msg.sender == module, \"Not authorized\");\n        if (operation == 1)\n            (success,) = to.delegatecall(data);\n        else\n            (success,) = to.call{value: value}(data);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}